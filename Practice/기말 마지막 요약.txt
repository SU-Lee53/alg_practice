기말고사: 그리디, 동적 계획법, NP문제, 근사 알고리즘


1. 그리디 알고리즘:
    - 가장 큰값부터 '욕심내어' 취함
    - 한번 정한 값은 번복하지 않음
    - 최적 부분 구조(최적성 원칙) -> 전체 문제의 답 안에 부분문제의 답이 포함되어있음
    - 위 특징들 때문에 제한적인 문제들만 풀 수 있다.

    1) MST-Kruskal
        - 최소신장트리: 그래프에서 사이클이 없고 가중치의 합이 최소가 되는 트리
        - Kruskal의 방법: 가장 작은 간선부터 취하고 사이클이 있다면 pass
        - 간선수 m, 정점수 n
        - 우선 간선을 정렬하고 순서대로 그리디 방법을 취함
        - 시간복잡도는 O(mlogm)

    2) MST-Prim
        - Kruskal의 방법과 다르게 시작점을 하나 정하고 주변 간선들중 가장 작은값을 취하여 트리를 확장시킴
        - 현재 만들어진 트리에서 그 주변점들의 가중치 정보를 갱신해나가면서 가중치가 최소인 간선을 취한다
        - 간선수 m, 정점수 n
        - 원래대로라면 O(n^2)인 알고리즘이지만 heap구조로 최솟값을 바로바로 뽑아올시 O(mlogn) -> m이 n에 비례하므로 최종적으로 O(nlogn)

    3) Dijikstra -> 최단 경로 찾기
        - 기본적으로 Prim의 MST 알고리즘과 매우 유사함
        - MST-Prim과의 차이점은 1. 간선을 추가하는 방법 2. 출발점이 정해져있음.
        - Prim은 현재 트리에서의 최소 가중치 간선, Dijikstra는 출발점에서부터 현재 경로까지 가중치를 모두 가져와야함
        - 이를 위해서 구현시에는 Origins 리스트를 따로 만들어 어디서부터 왔는지 저장한다.
        - 시간복잡도는 Prim처럼 O(n^2)이겠지만 마찬가지로 heap구조를 이용하여 O(nlogn)

    4) Set Cover -> 집합 커버 문제
        - 어떤 집합의 부분집합으로 이루어진 집합에서 가장 적은 원소만 합집합하여 원래집합을 만드는 문제
        - 최적해는 사실 못구하고 Greedy로 근사해를 구한다.
        - 원래 집합과 가장 많이 겹치는 부분집합을 찾고 해당 부분집합의 원소들을 원래 집합에서 제거
        - 위 과정을 반복한다.
        - 마지막에 가면 결국 1개짜리를 자꾸 고르게 되는데(안그럴수도있음) 이때문에 최적해에서 멀어진다.
        - 시간복잡도는 O(n^3) 근사비율은 k ln n -> k는 최적해의 집합수, n은 전체 원소 갯수

    5) Partial Knapsack -> 부분 배낭 문제
        - 진짜 별거없이 가치가 높은것부터 더이상 채울수 없을때까지 채움(전체를)
        - 그러다 더 넣을수 없는데 자리가 남으면 남은 물건들중 가치가 높은걸 남은자리만큼 채워넣음
        - 시간복잡도는 물건들을 정렬하는 시간 O(nlogn)

    6) Job Scheduling -> 작업 스케줄링
        - 최적해가 나오는 유일한 방법은 먼저 시작하는 놈을 기준으로 그리디 알고리즘을 쓰는것
        - 먼저 시작하는 놈들 부터 기계에 다 때려박고 그 다음부터는 먼저 끝나는 기계에 때려박으면 됨
        - 시간복잡도는 정렬에 O(nlogn) + m개의 기계에 n개의 작업을 집어넣는데 O(mn)

    7) Huffman Encoding -> 허프만 압축
        - 문자의 빈도수를 이용하여 트리로 만들고 비트를 부여한다 -> 빈도수가 높으면 비트수 적고 빈도수 낮으면 비트수 많음
        - 접두부 특성(Prefix Property) -> 어떤 문자의 비트가 101이면 101로 시작하는 문자도 없고, 1과 10도 존재하지 않음
        - 모든 문자는 단말노드에 존재하며 왼쪽은 0번, 오른쪽은 1번 부여
        - 빈도수를 모아둔 우선순위 큐에서 작은거 2개씩 뽑아서 트리에 추가해나가면 된다
        - 시간복잡도는 n개의 문자를 가지고 트리를 만드는데 O(nlogn)


2. Dynamic Programming 동적 계획법
    - 부분문제의 해를 이용하여 원래문제의 해를 구함
    - 이전의 부분문제의 해들은 모두 저장되고(Memoization) 언제꺼내쓸지 모름
    - 얘도 최적 부분 구조(최적성 원칙)을 따름. 부분문제의 해가 원래문제의 해에 포함되어있음
    - 그리디와 차이점: 한번 고정한 답을 번복하기도 함

    1) Floyd-Warshall -> 모든쌍 최단경로
        - 모든 쌍의 최단경로를 구함 -> 각각의 경유지를 추가하면서 가장 최단경로를 갱신해나간다
        - 3개의 loop -> D[i,k] + D[k,j] < D[i,j]라면 갱신
        - 3개의 loop를 도므로 O(n^3)
        - 구현이 쉽다. 다익스트라 n번 반복보다 일정 범위 내에서 빠를수도 있음

    2) 연속 행렬 곱셈
        - 연속된 행렬곱의 연산횟수의 최소 + 연산순서까지
        - 행렬의 연산횟수는 AxB 행렬과 BxC 행렬이 있으면 AxCxB(A열*C행 곱을 B만큼함)
        - 부분문제 크기 1부터 시작해서 점점 늘려나간다.
        - loop를 3번 도므로 시간복잡도는 O(n^3)

    3) 0-1 knapsack
        - 어떤 물건을 담았을때와 담지 않았을때를 나누어 부분문제를 계속 구한다
        - 배낭의 무게도 0부터 늘려가면서 최대값을 구한다
        - 결국 채워진 행렬의 우하단값이 해임
        - 시간복잡도는 O(nC) -> C가 배낭의 최대 무게

    4) 동전 거스름돈
        - 동전의 액면차가 정수배가 아닌경우 그리디로 해결 못하고 DP를 사용
        - 0-1 knapsack 문제와 기본적으로 같음
        - 시간복잡도는 O(nk) -> k가 n이 거스름돈 액수, k가 동전 종류수


3, 4. NP-Complete, 근사 알고리즘
    - 다항식 시간 내에 해를구할수 없는 문제가 NP문제
    - P는 NP의 부분집합임 -> NP의 비결정적인 해를 찾는 NP알고리즘이 P문제임
    - NP-완전 문제끼리는 변환가능
    - NP-하드: NP문제를 다항식 시간내에 풀도록 변환한 문제 -> NP에 속하지 않을수도 있음
    - NP-하드와 NP문제의 교잡합이 NP완전
    - 못푼다고 안푸냐 -> 근사해라도 찾고 근사비율 제시
    -NP문제의 예시
        - SAT
        - 0-1배낭
        - 분할
        - 독립집합
        - 클리크
        - 그래프 색칠
        - 해밀턴 경로 등등등

    - 근사 알고리즘
        1) TSP-MST
            - MST의 성질을 이용하여 외판원 순회 문제를 근사 구함
                - 2가지 가정
                    1. a-c 가 a->b->c보다 반드시 빠름(삼각 부등식 원리)
                    2. a->b와 b->a 는 같음 (대칭성)
            - 시간복잡도는 MST를 만드는 시간을 따름
            - 근사비율은 2.0

        2) Vertex Cover
            - 정점커버 -> 집합커버로 풀면 O(n^3)에다 근사비율도 klnn 존나 별로
            - 극대매칭을 이용하면O(mn)에다 근사비율도 2.0까지 내려온다

        3) 통채우기
            - 최초 적합
            - 다음 적합
            - 최선 적합
            - 최악 적합
            - 모두 근사비율 2.0에 다음적합빼고 다 시간복잡도가 O(n^2)

        4) 작업 스케줄링
        5) 클러스터링















